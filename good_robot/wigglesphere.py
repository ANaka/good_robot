# AUTOGENERATED! DO NOT EDIT! File to edit: 00_wigglesphere.ipynb (unless otherwise specified).

__all__ = ['dist_from_point', 'lines_to_layer', 'layer_to_lines', 'ChordArray']

# Cell
import bezier
from matplotlib.collections import LineCollection
from matplotlib import pyplot as plt
import numpy as np
from penkit import write, preview
from pathlib import Path
import seaborn as sns
from tqdm import tqdm

# Cell
def dist_from_point(line, point):
    '''calculate euclidean distance of a set of points from a reference point'''
    return ((line - point) ** 2).sum(axis=1) ** 0.5

# Cell
def lines_to_layer(lines):
    nanlines = []
    for line in lines:
        _line = np.concatenate([line,np.array([[np.nan, np.nan]])])
        nanlines.append(_line)
    nanlines = np.concatenate(nanlines)
    x = nanlines[:,0]
    y = nanlines[:,1]
    return (x,y)

# Cell
def layer_to_lines(layer):
    _layer = layer[1:,:]  # drop first row containing placeholder nan
    isnan = np.isnan(_layer[:,0]).nonzero()[0]
    lines = []
    start_ind = 0
    for nan_ind in isnan:
        line = _layer[start_ind:nan_ind,:]
        lines.append(line)
        start_ind = nan_ind + 1
    return lines

# Cell
class ChordArray(object):
    def __init__(self,
                 center=np.array([0.,0.]),
                 radius=1,
                ):
        self.center = center
        self.radius = radius
        self.chords = np.array([[np.nan, np.nan]])

    @property
    def center_x(self):
        return self.center[0]

    @property
    def center_y(self):
        return self.center[1]

    def radial_to_xy(self, r, theta):
        x = np.cos(theta) * r
        y = np.sin(theta) * r
        return (x, y)

    def gen_chord(self, theta0, theta1, radius0=None, radius1=None):
        if not radius0:
            radius0 = self.radius
        if not radius1:
            radius1 = self.radius
        x0, y0 = self.radial_to_xy(radius0, theta0)
        x1, y1 = self.radial_to_xy(radius1, theta1)
        chord = np.array([[x0, y0],
                             [x1, y1],
                             [np.nan, np.nan],
                            ])
        chord += self.center
        return chord

    def add_chord(self, theta0, theta1, radius0=None, radius1=None):
        chord = self.gen_chord(theta0, theta1, radius0, radius1)
        self.chords = np.append(self.chords, chord, axis=0)

    def gen_diameter(self, theta0, radius=None):
        if not radius:
            radius = self.radius
        theta1 = theta0 + np.pi
        return self.gen_chord(theta0=theta0,
                              theta1=theta1,
                              radius0=radius,
                              radius1=radius
                             )

    def add_diameter(self, theta0, radius=None):
        diameter = self.gen_diameter(theta0, radius)
        self.chords = np.append(self.chords, diameter, axis=0)

    def add_random_diameters(self, n_diameters=10):
        for theta in np.random.rand(n_diameters) * np.pi * 2:
            self.add_diameter(theta)

    def add_random_chords_at_set_theta_diff(self, n_chords, theta_diff):
        for theta0 in np.random.rand(n_chords) * np.pi * 2:
            theta1 = theta0 + theta_diff
            self.add_chord(theta0=theta0, theta1=theta1)
